# Фреймворки на стороне сервера

Node.js-фреймворков для сервера существует большое колличество.

## Примеры NodeJS фреймворков

- [hapi](https://hapi.dev/) - подходит для написания микросервисов
- [Express](https://expressjs.com/) - подходит для более крупных проектов
- [Sails.js](https://sailsjs.com/) - подходит, например, для компонента электронной коммерции

Часто для обширного проекта применяется сразу несколько таких фреймворков. Каждый для своей задачи.

**Виды библиотек и фреймворков**:

- _API-фреймворк_ - библиотека для построения API. Пример: [LoopBack](https://loopback.io/);
- _Библиотека HTTP-сервера_ - строят приложения на основе команд и машрутов HTTP. Пример [Koa](https://koajs.com/);
- _Фреймворк HTTP-сервера_ - строит модульные сервера, использующих HTTP для коммуникации. Пример: [hapi](https://hapi.dev/);
- _Веб-фреймворк MVC_ - фреймворки на базе паттерна MVC. Пример: [Sails.js](https://sailsjs.com/);
- _Полностековый фреймворк_ - используют JavaScript на стороне сервера и браузера и позволяют использовать совместно клиентский
  и серверный код (_изоморфтный код_). Пример: [DerbyJS](https://w.derbyjs.com/).

## Koa V1

Koa (версии 1) базируется на _Express_, но использует [генераторы](https://learn.javascript.ru/generators) (синтаксис ES2015) для определения функций промежуточной обработки (мидлваров).
Это позволяет писать практически синхронный код.

**Пример синтаксиса генераторов в JavaScript**: ./koa-example/generators.js

**Пример Koa-сервера версии 1 (генераторы)**: ./koa-example/index.js

**Пример использования koa-router**: ./koa-example/router.js

**Плюсы**: гибкая настройка за счёт расширения на основе множества миддлваров.

**Минусы**: трудоёмкость переноса функционала между проектами (повторого использования кода).

## Kraken

_Kraken_ базируется на Express, но за счёт модулей расширяет функционал. Самый популярный модуль - [Lusca](https://github.com/krakenjs/lusca), который
обеспечивает безопастность. Кроме того, _Kraken_ устанавливает более жёсткую структуру приложения в отличии от _Koa_ и _Express_.
_Kraken_ использует паттерн MVC и настраивается через файлы конфигурации.

**Плюсы**: строгая структура проекта. Структура так же однотипная от проекта к проекту (за счёт авто-генерации проекта). Встроенные шаблонизатор _Dust_ и интернационализация (Makara) позволяют легко создавать мультиязычные шаблоны.

**Минусы**: конфигурация проекта через файлы конфигурации, что обеспечивает плохую прозрачность при настройке. Сложность в изучении.

**Пример минимальной конфигурации проекта Kraken**: ./kraken-example

## hapi

_hapi_ берет сервер как главную абстрацию. Позволяет связывать несколько сервером посредством HTTP (микросервисная архитектура). Поддерживает API маршрутизации. Не обеспечивает поддержки на стороне клиента и баз данных. Удобен для задач DevOps (подключения, ведение журнала).

_hapi_ расширяется за счёт плагинов. В отличии от мидлваров в _Express_, плагины в _hapi_ расширяют функции сервера.

Плагин _inert_ - добавляет поддержку статики, обработчики каталогов.
Плагин _hapi-sequelizejs_ - позволяет генерировать REST API на основании ORM-моделей [Sequelize](https://sequelize.org/docs/v6/) баз данных.

**Плюсы**: более выразительный синтаксис плагинов, возможность разбиения сервера на кластеры (микросервисы).

**Минусы**: зависимость от множества плагинов (могут перестать поддерживаться), отсутствие структуры в проекта (в сравнении, например, с _Kraken_).

**Пример проекта**: ./hapi-example

## Sails

_Sails_ - MVC-фреймворк с ORM и автогерацией REST API и поддержкой веб-сокетов. Не является полностековым фреймворком, поэтому подходит для разных фронтенд-библиотек.

Установка и запуск:

```bash
npm i sails -g
sails new sails-project
cd sails-project
sails lift
```

_Нестандартные маршруты_ определяются в `config/routes.js``:
```javascript
'GET /example': { action:   'view-example' },
```

Сгенерировать контроллер можно следующей командой:
```bash
sails generate action view-example
```

Далее:
- создать соответствующий шалон: `views/pages/example.ejs`
- добавить его в исключения аутентификации в: `config/policies.js`.

### REST API в _Sails_

_Sails_ объединяет модели баз данных и контроллеры в API.

Установка _MySQL_ в _Sails_:
```bash
npm i --save waterline sails-mysql
```

Настройка подключения в `config/datastores.js`:
```javascript
module.exports.datastores = {
  default: {
    adapter: require('sails-mysql'),
    url: 'mysql://user:password@host:port/database',
  }
}
```

Генерация модели и контроллера для таблицы БД:
```bash
sails generate api TableName
```

Описание модели (пример): `sails-example/api/models/Comments.js`

Определение контроллера (пример): `sails-example/api/controllers/view-contact.js`

Шаблон для отображения данных (пример): `sails-example/views/pages/comment.ejs`

Маршрут в `config/routes.js`:
```javascript
module.exports.routes = {
  'GET /comment/:commentId': { action:   'view-comment' },
}
```

**Плюсы**: строгая структура, автогенерация проекта и его составляющих.

**Минусы**: нужно подстраиваться под стредства машрутизации _Sails_, сложность адаптации схемы БД под подход _Waterline_.

**Пример проекта**: `./sails-example`

## DerbyJS

_DerbyJS_ - полностековый фреймворк. Поддерживает синхронизацию и серверную визуализацию представлений (_MongoDB_, _Redis_).

### Установка и запуск MongoDB

```bash
# Добавление репозитория MongoDB: https://www.mongodb.com/docs/manual/administration/install-community/
sudo apt install mongodb-org mongosh
sudo systemctl start mongod
mongosh
```

### Установка и запуск Redis

```bash
# Добавление репозитория Redis: https://redis.io/docs/getting-started/installation/install-redis-on-linux/
sudo apt install redis
sudo systemctl start redis-server
redis-cli
```

Установка проекта (старая версия _DerbyJS_, совместимая с пакетом `derby-starter`):
```bash
npm install --save derby@0.10.22 derby-starter derby-debug
```

_DerbyJS_ позволяет создавать и запускать множество серверов. Для каждого сервера нужно:

- Создать каталог;
- модули: `server.js` (инициализация сервера) и `index.js` (подключение шаблонов, маршрутов и т.п.);
- шаблоны (минимально: `index.html`).

В главном каталоге проекта можно также создать модуль `server.js`, где с помощью `require()` можно импортировать все сервера, работающие на разных портах.

**Плюсы**: ORM баз данных (_MongoDB_, _Redis_), синхронизация и web-сокеты "из коробки".

**Минусы**: плохая поддержка проекта на текущий момент. Слабая мотивация переходить на _DerbyJS_ для людей, испольщующих _React_/_Vue_ и владеющих _WebSockets_.

**Пример проекта**: ./derby-example
