# Хранение данных в приложениях

Реляционные базы данных основаны на концепции реляционной алгебры и теории множеств. _Scheme (схема)_ описывает формат различных типов данных и связи между ними. Например, типы: User и Post. Связь User и Post: один ко многим. На языке _SQL (Structured Query Language)_ выполняются запросы к базе данных.

## PostgreSQL

Установка в Debian 12:

```bash
# Устанавливаем последнюю версию
sudo apt update
sudo apt install postgresql
# Проверить статус демона
sudo systemctl status postgres
```

Создание пользователя (роли):

```bash
# аутентифицируемся под пользователем postgress
sudo -su postgres
# запускаем postgres repl:
psql
# создаём новую роль с именем своего пользователя
CREATE ROLE username;
# устанавливаем пароль для роли
ALTER ROLE username WITH PASSWORD 'password';
# даём права на вход и создание новых баз данных
ALTER ROLE username LOGIN CREATEDB;
# проверяем наличие новой роли и превилегии
\du
# выходим из repl
exit
# завершаем сессию пользователя postgres
exit
```

Создание базы данных и вход:

```bash
createdb database-name
psql -d database-name
```

Удаление базы данных:

```bash
dropdb database-name
```

### Postgres в Node

Установка клиента:

```javascript
npm i --save pg
```

Пример подключения к базе данных:

```javascript
const pg = require('pg');

// создание клиента
const db = pg.Client({
    user: 'username',
    password: 'password',
    database: 'database-name',
});

// подключение к базе данных
db.connect((err, client) => {
    if (err) throw err;
    console.log(`Connected to: ${db.database}`);
    db.end(); // закрытие подключения
})
```

`\dt` - просмотр всех таблиц

Создание таблицы:

```javascript
// SERIAL - числовой тип данных, по-умолчанию
// присваивающий вместо null следующее число
db.query(`
    CREATE TABLE IF NOT EXISTS table-name (
        id SERIAL,
        PRIMARY KEY(id),
        body TEXT
    );
`, (err, result) => { /* ... */ });
```

Добавление записи c добавлением id в результат:

```javascript
db.query(`
    INSERT INTO table-name (row) VALUES ('value')
    RETURNING id
`, (err, result) => {
    if (err) throw err;
    const [{ id }] = result.rows;
    console.log('Created row with id:', id);
});
```

Обновление полей в записи:

```javascript
const id = 0;
db.query(`
    UPDATE table-name SET column-name = 'new_value'
    WHERE id=${id};
`, (err, result) => {
    if (err) throw err;
    console.log('Updated rows count:', result.rowCount);
});
```

Выборка данных из таблицы, упорядоченных по полю id:

```javascript
db.query(
    'SELECT * FROM table_name ORDER BY id;',
    (err, result) => {
        if (err) throw err;
        console.log(result.rows); // массив с записями
    }
)
```

`TABLE table_name;` - просмотр всех записей в таблице
`\d table_name;` - просмотр структуры таблицы


### Knex

Установка:

```bash
npm i --save knex
# Дополнительно нужны драйвера используемых баз данных
# Например: Sqlite и Postgress
npm i --save sqlite3 pg
```

Подключение и использование Knex
```javascript
const knex = require('knex');

// пример подключения Sqlite
const db = knex({
    client: 'sqlite3',
    connection: {
        filename: 'db.sqlite' // или :memory: для хранения данных в ОЗУ
    }
});

// пример подключения к Postgress
const db = knex({
    client: 'pg',
    connection: {
        database: 'articles',
        username: 'username',
        password: 'password'
    }
});

// создание таблицы
const createTable = async () => {
    const tableIsExists = await db.schema.hasTable('articles');
    if (!tableIsExists) {
        await db.schema.createTable('articles', (table) => {
            table.increments('id').primary();
            table.string('title');
            table.text('content');
        });
    }
};

createTable().then({
    // добавить новую запись
    db('articles').insert({ title: 'title', content: 'content' });
    // получить все записи таблицы, отсортированные по полю "title"
    db('articles').orderBy('title');
    // получить запись по id
    db('articles').where({ id: 0 }).first();
    // удалить запись
    db('articles').del().where({ id: 0 });
});
```

#### Безопасные абстрации

Из-за того, что разные БД имеют специфичные элементы синтаксиса, одни и те же абстрации могут работать и не работать от БД к БД. Например:

```javascript
table.increments('id').primary(); // работает и в Sqlite и в PosgreSQL
table.integer('id').primaery(); // работает в Sqlite, но не работает в PosgreSQL
```

### Различия MySQL и PosgreSQL

- PostgreSQL поддерживает сложные типы данных: массивы, JSON, пользовательские типы;

- PosgreSQL поддерживает полнотекстовый поиск;

- В PosgreSQL строгое соответствие стандарту ANSI SQL:2008;

- Репликация в MySQL мощнее;

- Сообщество MySQL больше, больше и самих инструментов;

- У MySQL есть дефрагментация на ветви: MySQL, MariaDB, WebScaleSQL и т.д.;

- Быстродействие при масштабировании в обеих БД зависит от множества факторов - проверять нужно на практике.

## ACID

- Атомарность (Atomicity);
- Согласованность (Consistency);
- Изолированность (Isolation);
- Устойчивость (Durability);

Чем выше показатель ACID - тем ниже быстродействие системы.

### Атомарность

Неделимость операций/действий, неделимость данных. Например, если удалаются все комментарии пользователя, не может быть удалина лишь часть из них (даже при ошибке/сбое в питании).

### Согласованность

Целостность данных после транзакций. Например, уникальность первичных ключей, соотвествие данных _схеме_ и т.д. Так же есть понятие _согласованности_ в аббривиатуре _CAP_ (C), где значение - это единство представления данных для всех пользователей в распределенной системе.

### Изоляция

Элементарный способ избавиться от коллизий - блокировать все запросы, пока выполняется текущий. Другой подход - позволять системе выполнять параллельные транзакции с разной степенью изолированности (на уровне таблиц, записей, полей).

### Устойчивость

Определеяет степень, с которой эффект после транзакции сохранится после перезагрузки/сбоя программы и т.п. При сохранении данных в ОЗУ - низкая устойчивость, а на жёсткий диск - высокая.

## NoSQL

_NoSQL (Not only SQL)_ - все нереляционные базы данных, некоторые из которых поддерживает язык SQL.

Парадигмы NoSQL баз данных:

- ключ/значение, кортежи (Redis);

- графовые БД (Neo4J);

- документные БД (MongoDB);

- Столбцовые БД (Cassandra);

- БД временных рядов (Graphite);

Существуют многопарадигмальные БД, например: Couchbase.

Схемы доступа в релационных БД создают основную нагрузку на приложение. Требутеся нормализация данных (преобразование запросов для сокращения операций чтения при потреблении данных БД клиентом).

NoSQL денормализуются по умолчанию, что сокращает время на моделирование данных и даёт более гибкую и производительную архитектуру.

## Распределенные БД

Есть вертикальное масштабирование (увеличение ресурсов машины) и горизонтальное (увеличение количества машин). При горизонтальном масштабировании применяются _распределенные БД_. Некоторые реляционные системы также способны работать с горизонтальным масштабированием в форме репликации: "главный/подчиненный", "главный/главный". Но, например, у MySQL максимальное количество кластеров - 255.

### MongoDB

_MongoDB_ - документно-ориентированная распределенная база данных.

Документы хранятся в бесхемных коллекциях. Документ не всегда строится по заранее определенной схеме, а документы одной коллекции не всегда совместно используют одну схему. Поэтому на приложение ложится ответственность за _согласованность_ (ACID).

Установка и запуск MongoDB

```bash
# Добавление репозитория MongoDB: https://www.mongodb.com/docs/manual/administration/install-community/
sudo apt install mongodb-org mongodb-mongosh
sudo systemctl start mongod
mongosh
```

NodeJS драйвер:

```bash
npm i --save mongodb
```

Использование драйвера:

```javascript
const { MongoClient } = require('mongodb');

MongoClient.connect('mongodb://127.0.0.1:27017')
    .then((client) => {
        console.log('Client is ready');
        const db = client.db('db-name');
        client.end();
    })
    .catch(console.error);
```

Большинство взаимодействий с MongoDB осуществляется через коллекции:

`collection.instert(doc)` - вставка документа/документов;
`collection.find(query)` - поиск документов по запросу;
`collection.remove(query)` - удаление документов, соотвествующих запросу;
`collection.drop()` - удаление всей коллекции;
`collection.update(query)` - обновление документов, соответствующих запросу;
`collection.couht(query)` - количество документов в коллекции, удовлетворяющих запросу.

Также есть разновидности запросов для поиска одного/многих документов. Например:

`collection.instertOne(doc)` - поиск одного документа;
`collection.instertMany([doc, doc])` - поиск многих документов.

Примеры:

```javascript
// Добавление документа
const article = {
    title: 'title',
    content: 'content',
};
db.collection('collection-name')
    .instertOne(article)
    .then((result) => {
        // если в исходном объекте нет id, он создаётся
        console.log(result.insertedId.toString());
        // в исходный объект добавляется свойство _id
        console.log(article._id.toString());
    })

// Поиск всех документов с таким заголовком
db.collection(collectionName)
    .find({ title: 'Title of this article' })
    .toArray()
    .then((results) => {
        console.log(results);
    })

// Поиск по id
db.collection(collectionName)
    .findOne({ _id: new ObjectId('65423630b2943c544ab7be2a') })
    // ...

// Поиск по регулярному выражению
db.collection(collectionName)
    .find({ title: { $regex: /^Title(.)*/ }})
    // ...
```

Идентификатор (_id) кодируется с помощью _BSON_ (Binary JSON) и инкапслуриуется в ObjectId;

Получить временную метку создания документа (createdAt):

```javascript
const id = new ObjectId('any-id')
id.getTimestamp();
```

Объект assert (NodeJS):

```javascript
const assert = require('node:assert');

try {
    assert.strictEqual(1, 2);
    console.log('OK');
} catch {
    console.log('1 !== 2');
}
```

Сравнение _id в документах коллекций:

```javascript
// С помощью встроенного метода в ObjectId:
article1._id.equals(article2._id);
// С помощью deepEqual (из модуля node:assert)
assert.deepEqual(article1._id, article2._id);
// С помощью приведение к строковому типу
String(article1._id) === String(article2._id);
```

Создание id из строки:

```javascript
const { ObjectId } = require('mongodb');
const strID = '577f6b45549a3b991e1c3c18';
const bsonID = new ObjectId(strID);
```

#### Реплицированные наборы

Процессы _MongoDB_ могут выполняться как участники реплицированного набора (replica set). Реплицированный набор состоит из одного первичного узла и множества вторичных. У каждого узла свои порт и каталог.

```bash
# завершаем предыдущие процессы MongoDB
sudo pkill mongod
# даём 3 секунды завершить всем процессам
sleep 3

# Формируем реплицированный набор
mongod --port 27017 --dbpath ./mongodata/db0 --replSet rs0
mongod --port 27018 --dbpath ./mongodata/db1 --replSet rs0
mongod --port 27019 --dbpath ./mongodata/db1 --replSet rs0

# инициализируем первичный узел (по умолчанию порт 27017)
mongosh --eval "rs.initiate()"

# добавить узлы в репликационный набор
mongosh --eval "rs.add('127.0.0.1:27017')"
mongosh --eval "rs.add('127.0.0.1:27018')"
mongosh --eval "rs.add('127.0.0.1:27019')"
```

Клиенты MongoDB должны располагать информацией обо всех хостах. Но не все хосты должны быть активны (минимум два). Если первичный узел станет недоступен - любой вторичный узел возьмёт на себя эту роль.

```javascript
const { MongoClient } = require('mongodb');
const host = '127.0.0.1';
const hosts = [
    `${host}:27017`,
    `${host}:27018`,
    `${host}:27019`
];

MongoClient.connect(
    `mongodb://${hosts.join(',')}`,
    { replicaSet: 'rs0' }
)
    .then((client) => {
        const db = client.db('db-name');
        db.admin().replSetGetStatus()
            .then((status) => {
                console.log(status);
                client.close();
            })
    });
```

#### Уровень записи

Можно точно управлять балансом между скоростью и надежностью записи данных c помощью уровней _уровней записи_ (write concern). 

Уровень записи - числовое значение, определяющиее, во скольких узлах должна быть произведена запись, чтобы операция была признана успешной.

При нулевом значении мы получаем максимальное быстродействие для некритичных данных (логи, кэш данных и т.п.).

Пример:

```javascript
// быстрая запись, без гарантированных узлов
db.collection('collection-name')
    .insertOne(data, { writeConcern: { w: 0 }});

// динамическое определение количества узлов в репликационном наборе
// гарантирует, что запись произведена в более 50% узлов
db.collection('collection-name')
    .insertOne(data, { writeConcern: { w: 'majority' }});
```

Максимально надёжное решение - распределенные узлы в разных дата-центрах. И одновременно это самое медленное решение.

## Redis (хранилище "Ключ-значение")

Хранилища "ключ-значение" хранят пары, где значением могут быть данные любого типа. Эти данные всегда атомарны - воспринимаются и передаются как неделимое целое. Часто хранилища "ключ-значение" встречаются в частях приложения, требовательных к быстродействию. Поэтому недерко используется временная память для хранения данных, таких как: кэш, временные данные и т.п.

_Redis_ - хранилище структур данных, где пара "ключ-значение" лишь одна из структур хранения данных. 

Структуры данных _Redis_: строки, хэши, списки, множества, сортированные множества. 

Возможности и особенности _Redis_: работа с растровыми данными, геоданными, каналами (публикация/подписка), установка TTL (срок жизни), LRU (вытеснение из памяти неиспользуемых данных), репликация/кластеризация, расширение команд (Lua) и т.д.

Установка и запуск сервера _Redis_:

```bash
# Добавление репозитория Redis: https://redis.io/docs/getting-started/installation/install-redis-on-linux/
sudo apt install redis
# по умлочанию redis будет слушать порт: 6379
sudo systemctl start redis-server
redis-cli
```

Установка драйвера:

```bash
npm i --save redis
# повышает производительность
# требует gcc/g++ и python 2.x (c версиями 3.x не работает)
npm i --save hiredis
```

Пример использования:

```javascript
const { createClient } = require('redis');
// создание клиента к Redis
const client = await redis.createClient();
// вешаем слушатель события (экземляр клиента расширяет EventEmmiter)
client.on('connect', () => console.log('Connection established'));
// подключение клиента к серверу
await client.connect();
// установка и получение значения по ключу
client.set('color', 'red');
const value = await client.get('color');
console.log(value);

// проверка на существование ключа
const keyIsExists = await client.exists('color');
console.log(keyIsExists); // 1

// создание хэша
await client.hSet('food', {
    name: 'cookie',
    type: 'with milk',
});
// получение значений из хэша
const values = await client.hmGet('food', ['name', 'type']);
console.log(values);
// получение всех ключей хэша
const hashKeys = await client.hKeys('food');
console.log(hashKeys);

// добавление элементов в список
await client.lPush('tasks', 'taks one');
await client.lPush('tasks', 'task two');
// извлечение всех элементов списка
const listElements = await client.lRange('tasks', 0, -1);
console.log(listElements);

// добавление элементов в множество
await client.sAdd('clients', 'Alice');
await client.sAdd('clients', 'Bob');
await client.sAdd('clients', 'Alice'); // только уникальные значения
// вывод элементов множества
const setElements = await client.sMembers('clients');
console.log(setElements);

// отключение клиента
await client.disconnect();
```

Команды добавления/изменения значений:

- `set` (устанавливает пару ключ-значение);

- `append` (добавление данных к существующему значению);

- `mset` (устанавливает перечисленные через пробел пары ключ-значение);

- `setnx` (устанавливает значение, только если ключ ещё не существует);

- `msetnx` (если хоть один ключ в списке устанавливаем уже есть - ничего не делает);

- `setex` (устанавливает ключ-значение на указанное время в секундах);

- `psetex` (аналог `setex`, но в миллисекундах);

- `setrange` (заменяет подстроку начиная с указанного значения (offset));

Команды чтения значений:

- `get` (читает значение по указанному ключу);

- `mget` (возвращает значения всех перечисленных через пробел ключей);

- `getrange` (получение подстроки с указанием индексов начала и конца);

- `getset` (устанавливает новое значение и возвращает старое).

Команды увелчиения/уменьшения значений:

- `incr` (увеличивает значение на 1);

- `incrby` (увеличивает значение на указанное число);

- `incrbyfloat` (увеличивает значение на вещественное число);

- `decr` (уменьшает значение на 1);

- `decrby` (уменьшает значение на указанное число).

Информационные команды:

- `strlen` (возвращает длину строчного значения).

Команды для работы с ключами:

- `exists` (возвращает 1, если ключ существует, 0 - если нет);

- `del` (удалаяет перечисленные ключи);

- `rename` (переименовывает ключ на указанное имя);

- `renamenx` (переименовывает ключ на новый_ключ, если новый_ключ не существует);

- `sort` (сортирует списки и наборы числовых/строковых значений);

- `scan` (выводит список ключей в базе данных, используя курсор для перемещения);

- `type` (возвращает тип хранимого значения ключа).

Команды для работы с хэшами:

- `hdel` (удаление перечисленных полей из хэша);

- `hexists` (проверяет существование поля в хэше);

- `hget` (получить значение поля из хэша);

- `hgetall` (получить все поля их значения из хэша);

- `hincrby` (увеличивает значение поля в хэше на заданное число);

- `hincrbyfloat` (увеличивает значение поля в хэше на заданное вещественное число);

- `hkeys` (получить список всех ключей в хэше);

- `hlen` (получить количество всех ключей, хранимых в хэше);

- `hmget` (получить значения перечисленных полей в хэше);

- `hset` (добавить перечисленные поля и значения в хэш);

- `hsetnx` (добавляет поле со значением в хэш только если это поле ещё не существует);

- `hstrlen` (длина строкового значения поля хэша);

- `hvals` (возвращает все значения поле хэша);

- `hscan` (аналог `scan` для полей хэша).

Команды для работы со списками:

- `lpop` (извлечение первого элемента из списка);

- `blpop` (блокирует соединение, если ни один из перечисленных ключей не существует, пока другой клиент не добавит (`lpush`) один из данных ключей);

- `rpop` (удаляет последний элемент из списка);

- `brpop` (блокирует подключение, если ни один из списков не существует, пока другой клиент один из них не создаст. Удаляет последний элемент из первого существующего списка);

- `lindex` (возвращает значение элемента списка с указанным индексом);

- `linsert` (вставляет элемент перед или после указаного элемента списка);

- `llen` (возвращает длину списка);

- `lpush` (вставляет элемент в начало списка);

- `lpushx` (вставляет элемент в начало, только если указанный ключ существует и это список);

- `lrange` (возвращает элементы списка, выбранные из указанного диапозона);

- `lrem` (удаляет указанное количество элементов из списка, равных указанному значению)

- `lset` (устанавливает новое значение элемента списка с указанным индексом)

- `rpush` (вставляет все перечисленные элементы в конце списка);

- `rpushx` (вставляет перечисленные элементы в конец, только если ключ существует и это список);

- `ltrim` (обрезает список по заданным индексам start и end).

Команды для работы с множествами:

- `sadd` (добавляет перечисленные значения в множество);

- `scard` (получить количество элементов множества);

- `sdiff` (разница первого множества и всех перечисленных после него);

- `sdiffstore` (сохраняет разницу между множествами в новом множестве с указанным ключом);

- `sinter` (получить пересечение (одинаковые элементы) всех перечисленным множеств);

- `sinterstore` (сохраняет пересечение перечиленных множеств в новом множестве с указанным ключом);

- `sismember` (возвращает 1, если элемент принадлежит множеству, 0 - если нет);

- `smembers` (получить все элементы множества);

- `spop` (Удалить и получить один или несколько случайных элементов множества);

- `srandmember` (получить один или несколько случайных элементов множества);

- `srem` (удалить перечисленные элементы из множества);

- `sunion` (получить объединение перечисленных множеств);

- `sunionstore` (сохранить результат объединения перечисленных множеств в множестве с указанным ключом);

- `sscan` (аналог `scan` для вывода списка элементов множества).

В _Redis_ значения хранятся в виде двоичного набора данных (независимо от кодировки). Поэтому в качестве ключа и его значения могут выступать любые наборы символов.

По умолчанию ключи и значения преобразуются в строки. _Redis_ умеет считывать числа, строки, логические значения, даты и объекты буферов (ArrayBuffer). Все остальные типы (Object, Array, RegExp) _Resis_ преобразовать не сможет.

### Буферы в NodeJS

Буферы - двоичные данные, которые возвращаются по умолчанию базовыми API при работе с файлами и сетями. Представляют собой контейнеры для смежных блоков двоичных данных. Реализуютя в Node субклассом `Uint8Array`. Также в JS присутствуют и другие типы для двоичных данных: `Uint16Array`, `Uint32Array`, `Float32Array`, `Float64Array`.

В _Redis_ предусмотрены команды для работы с битами: `bitcount`, `bitfield`, `bittop`, `setbit`, `bitpost`.

### Sub/Pub в Redis

Механизм подписки/рассылки в _Redis_ позволяет подписывать клиентов на каналы и отправлять в эти каналы сообщения.

Пример функционала Sub/Pub: `./redis-project/chat.js`.


## Встроенные базы данных

Встроенные базы данных не требуют установки и администрирования внешних сервисов. Работают внутри процесса приложения. Взаимодествия со втроенными БД осуществляется напряму, с помощью вызова процедур в приложении, вместо передачи данных через IPC или по сети.

Чаще всего используются в мобильных и десктопных приложениях, где нужна автономность. В веб-сервисах используются для управления кэшем и сеансами пользователя. Примеры: SQLite, LevelDB, NeDB, LokiJS, Lodb. Последние три написаны на чистом JavaScript, что делает их нативным решением для среды Node.

### LevelDB

Встроенное хранилище пар ключ-значение. Хранит байтовые массивы, отсортированные по ключу в памяти диска (не в ОЗУ). Использует всего несколько операторов: `Get`, `Put`, `Del`, `Batch`. Умеет сохранять снимки (snapshots) состояния хранилища и создавать двусторонние итераторы (для перебора в обоих направлениях).

Поддержка в NodeJS обеспечивается двумя пакетами:

- LevelDOWN (С++ прослойка);

- LevelUP (API для NodeJS, инкапсулирующий интерфейс итераторов в потоках Node, поддерживающий кодирование ключей и значений, JSON и буферизацию команд до подключения к хранилищу).

Установка:

```bash
# пакет "level" включает в себя LevelDOWN и LevelUP.
npm i --save level
```

Команды:

`db.put(key, val, cb)` - добавить ключ-значение;
`db.get(key, cb)` - получить значение по ключу;
`db.del(key, cb)` - удалить ключ;
`db.batch().write()` - выполнение пакетных операций;
`db.createKeyStream(opts)` - создание потока ключей из БД;
`db.createValueStream(opts)` - создание потока значений.

Подключение клиента:

```javascript
const { Level } = require('level');

// принято каталог именовать с суфиксом ".db"
const db = new Level('./app.db', {
    keyEncoding: 'utf8',
    valueEncoding: 'json',
});
```

Поддерживаемые форматы кодирования: utf8, JSON, binary, id, hex, ascii, base64, ucs2, utf16le. Можно определять собственные кодировки.

_Примечание_: в отличии от документно-ориентированных БД (MongoDB), в LevelDB в JSON-данных нельзя обратиться к свойствам. JSON-данные сериализуются и становятся непрозрачными.

Пример добавления, чтения и удаления пары ключ-значение:

```javascript
// добавление
db.put('user', { name: 'Alice' }, (err) => {
    if (err) throw err;
    // чтение
    db.get('user', (err, result) => {
        if (err) throw err;
        console.log(result);
        // удаление
        db.del('user', (err) => {
            if (err) throw err;
        });
    });
});
```

Ошибка из-за отсутствия ключа в базе имеет поле: `err.notFound`, по которому её можно отличать от остальных ошибок:

```javascript
db.get('key', (err, result) => {
    if (err.notFound) console.log('Key not found');
    // ...
})
```

Можно переопределять опции подключения для отдельных запросов:

```javascript
const options = {
    keyEncoding: 'binary',
    valueEncoding: 'hex'
};

db.put(new Uint8Array([1, 2, 3]), 0xFFBB00, options, (err) => { /*...*/ });
```

#### Другие подсисистемы баз данных

Отделение LevelDOWN и LevelUP позволяет заменить первую на любую другую базу данных, поддерживающую _MemDown API_. Среди поддерживаемых баз данных: MySQL, Redis, MongoDB, файлы JSON, веб-хранилища браузера (localStorage).

Пример использования подсистемы _memdown_ (для хранения данных - строки и буфферы - в ОЗУ):

Установка:

```bash
# пакет leveldown нам не нужен, поэтому пакет level избыточен 
npm i --save levelup memdown
```

Использование:

```javascript
const levelup = require('levelup');
const memdown = require('memdown');

const db = levelup(memdown());

db.get('key', { asBuffer: false }, (err, result) => {
    if (err) throw err;
    console.log(result);    
});
```

Расширить типы кодирования данных, помимо строк и буфферов, можно с помощью пакета `encoding-down`:

```javascript
const encoding = require('encoding-down');

const db = levelup(encoding(memdown(), {
    valueEncoding: 'json',
}));

db.put('key', { value: 'value' }, (err) => {
    //...
});
```

Существует [множество расширений](https://www.npmjs.com/search?q=leveldb) для LevelDB, дополняющих её функциональность от поддержки геопространственных запросов и до репликаций и поддержки SQL.

#### Затратные операции

Сериализация и десериализация JSON - затратные процедуры. Кроме того, `JSON.stringify()` и `JSON.parse()` блокируют выполнение кода.

Для экономии затрачиваемого времени стоит придерживаться правил:

- сокращать общее количество процедур сериализации и десерализации;

- упрощать и уменьшать объем и структуру JSON-данных;

- рассмотреть другие форматы сериализации: _MessagePack_, _Protocol Buffers_.

Пример затрачиваемого времени на обе процедуры: `./leveldb-project/serialize-load.js`.

## Хранение данных в браузере

Узкое место в любом приложении - операции ввода/вывода с циклической передачей данных на сервер и их обработкой на той стороне (сохрение в БД). 

Разумно часть данных пользователя хранить на стороне же пользователя. Для этой задачи существуют _веб-хранилища_, привязанные к домену и хранящие пары ключ-значение.

Существует два API веб-хранилища:

- _sessionStorage_ (хранит данные в одной вкладке, пока не истечен строк жизни сессии или не будет закрыта влкадка/браузер);

- _localStorage_ (хранит данные, доступные в разных вкладках и устойчивые к из закрытию и перезагрузке браузера).

Веб-хранилища были разработаны для обхода ограничений Cookie, которые:

- Не могут передавать данные между активными вкладками;

- Плохо подходят для долгосрочного хранения данных.

Веб-хранилища предусмотрены в мобильных и десктопных браузерах. Для мобильных браузеров ограничение объема веб-хранилищ равно 5 МБ.

Сводное API _localStorage_:

- `localStorage.setItem(key, value)`; - добавляет ключ;

- `localStorage.getItem(key)`; - возвращает значение ключа;

- `localStorage.removeItem(key)`; - удаляет ключ;

- `localStorage.clear()`; - удаляет все ключи и значения;

- `localStorage.key(index)`; - возвращает имя ключа с заданным индексом;

- `localStorage.length` - общее количество ключей в хранилище.

И ключ и значения в _localStorage_ должны быть строками. Более сложные данные нужно преобразовывать к строке и обратно:

```javascript
const data = { arr: [1, 2, 3] };
localStorage.setItem('key', JSON.stringify(data));
console.log(JSON.parse(localStorage.getItem('key')));
```

Операции чтения/записи на стороне клиента блокируют UI-поток. У localStorage нет встроенных стредств для поиска значений и перебора ключей:

```javascript
// массив ключей в localStorage
const storageKeys = Object.keys(localStorage);
// массив значений ключючей в localStorage
const storageValues = storageKeys
    .map((key) => localStorage.getItem(key));
```

Также у localStorage нет встроенного механизма управления пространствами имен, но можно из формировать с помощью префиксов в названии ключей:

```javascript
// пространство имен "users"
localStorage(`/users/${user.id}`, JSON.stringify(user));
// пространство имен "comments"
localStorage(`/comments/${comment.id}`, JSON.stringify(comment));
```

Для оптимизации трузатратных операций localStorage может применяться для мемонизации результатов таких операций:

```javascript
const memoizeOpeartion = (data) => {
    const key = `/memoized/${JSON.stringify(data)}`;
    if (localStorage.getItem(key)) {
        // если операция уже выполнялась - просто извлекаем
        // результаты операции из localStorage
        return localStorage.getItem(key);
    }
    // выполняем сложную операцию только в первый раз
    // и сохраняем результаты в localStorage
    const result = expensiveWork(data);
    localStorage.setItem(key, result);
    return result;
}
```

Другие темы, относящиеся к хранению данных в браузере: `IndexedDB`, `Service workers`, `Offline-first`.

### LocalForage

Основные недостатки веб-хранилищ - блокирующий API и ограниченный размер хранилища. Неблокирующие альтернативы с большим размером памяти имеют свои недостатки: _WebSQL_ считается устаревшим, а _IndexedDB_ сложный API и исправления для поддержки в браузерах.

_LocalForage_ - библиотека нормализации интерфейса от Mozilla. Имеет схожий API с localStorage, поддерживая Promises и callback-функции:

- `localforage.setItem(key, value, cb)`; - добавляет ключ;

- `localforage.getItem(key, cb)`; - возвращает значение ключа;

- `localforage.removeItem(key, cb)`; - удаляет ключ;

- `localforage.clear(cb)`; - удаляет все ключи и значения;

- `localforage.key(index, cb)`; - возвращает имя ключа с заданным индексом;

- `localSlocalforagetorage.length(cb)` - общее количество ключей в хранилище.

Дополнительные функции:

- `localforage.keys(cb)` - возвращает все ключи в хранилище;

- `localforage.iterate(iterator, cb)` - перебор ключей-значений.

Установка:

```bash
npm i --save localforage
```

Просто подключить в index/app.html:
```html
<script src="localforage.js"></script>
```

_localforage_ пытается последовательно использовать доступные в браузере хранилища. Можно определить приоритет и исключить ненужные:

```javascript
// порядок используемых хранилищ (localStorage не использовать)
localforage.setDriver([localforage.INDEXEDDB, localforage.WEBSQL]);
```

_localforage_ позволяет хранить строки, числа, массивы, объекты, бинарные типы данных (TypedArray, ArrayBuffer, Blob).

### Виртуальное хранение данных

Многие хостинг-провайдеры предлагают готовые виртуальные машины с настроенными базами данных.

Для хранения файлов подходит сервис _S3_ на базе _AWS (Amazon Web Services)_. C помощью REST-совметимых вызовов HTTP файлы загружаются с гнёзда (buckets), а затем извлекаются оттуда через GET-запросы или протокол BitTorrent. Файлы преобазуются также в CDN и доставляются сервисом CloudFront CDN. Файлы могут загружаться прямо с клиентского приложения.
